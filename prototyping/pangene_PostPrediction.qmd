---
title: "pangene_wflow"
format: html
editor: visual
---

## Pangene workflow: post gene prediction

```{r}
Sys.setenv(merged_gff = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/merge_purge/v3.cat.clean.gff3",
          stringtiegtf = "/workspace/hrtjbs/pangene_2024/stringtie/fsrclf_merged.gtf")

```

#### Create scoring table from gff file. This file is a merge of Braker3 predictions and liftoff genes:

```{r}

library(stringr)
library(tidyr)
library(dplyr)

#read in the gff file containing the merged braker3 and liftoff genes
gff = read.csv("/workspace/hrtjbs/pangene_2024/pangene/prototyping/merge_purge/v3.cat.clean.gff3",skip = 3,sep = "\t",header = FALSE)

#grab just the transcripts
gff.transcripts = merged.v1 %>% filter(V3 == "mRNA")

#get various descriptors parent id, transcipt id and name (nid)
pid = str_extract(string = gff.transcripts$V9,pattern = "(?<=Parent=)[^;]+")
tid = str_extract(string = gff.transcripts$V9,pattern = "(?<=ID=)[^;]+")
nid = str_extract(string = gff.transcripts$V9,pattern = "(?<=Name=)[^;]+")

#add these to df
gff.transcripts$tid = tid 
gff.transcripts$pid = pid
gff.transcripts$nid = nid

#extract just the columns we need to begin the scoring table, make all different braker methods = Braker3
scoring_df = gff.transcripts %>%
  mutate(ID = coalesce(nid, pid)) %>%
  select(ID,V2,tid) %>%
  dplyr::rename("Method" = V2) %>% 
  mutate(Method = ifelse(Method == "Liftoff", Method, "Braker3"))


  
```

**Notes:**\
While the Braker gff3 file naming will be constant, the naming of genes from liftoff will vary. This script has been written to work with the naming we have in our kiwfruit annotations i.e. "Name" = the highest order of gene feature. Full version will need to to have a generalised approach to get highest level feature.

#### Transcript evidence for gene models: Using stringtie assembly to assess gene models

Here we are using gffcompare to categorise each transcript as to whether it matches rna-seq evidence (as described in stringtie assembly gtf). This uses an\
output file from transcriptome assembly (stringtie) that will already be produced earlier in the Braker3 pipeline.

We are assuming that user provided genes are infallable so we won't need to do this against liftoff genes in the actual pipeline. Here i am doing it with our full gene set out of curiosity\
and to estimate how good the Braker3 predictions are in comaprison

```{bash}
cat << EOF > gffcompare.sl
#!/bin/bash -e
#SBATCH -J gffcompare
#SBATCH --output=gffcompare.%j.out
#SBATCH --error=gffcompare.%j.err
#SBATCH --cpus-per-task=4
#SBATCH --mem=8G
#SBATCH --time=12:00:00

module load gffcompare/0.12.2
gffcompare -r $stringtiegtf \
-G \
-o v3.cat.clean.vs.transcripts \
$merged_gff
EOF
sbatch gffcompare.sl

```

#### Run database searches against eggnog, swissprot and Tair

These will be used to score the gene models and for functional annotation

```{bash}
cd /workspace/hrtjbs/pangene_2024/pangene/prototyping
mkdir -p /workspace/hrtjbs/pangene_2024/pangene/prototyping/eggnog_out.fork

cat << EOF  > eggnog.annotation.fork.sl
#!/bin/bash
#SBATCH -J egg_nog
#SBATCH -o egg_nog_job_output.%j.out
#SBATCH -e egg_nog_job_errors.%j.err
#SBATCH --cpus-per-task=12
#SBATCH --mem=12G
#SBATCH --time=24:00:00

module load conda
conda activate /workspace/hrtjbs/software/eggnog

emapper.py --cpu 12 \
-i /workspace/hrtjbs/pangene_2024/refGenome/v3.cat.clean.proteins.fasta \
--output_dir /workspace/hrtjbs/pangene_2024/pangene/prototyping/eggnog_out.fork \
--data_dir /workspace/hrtjbs/software/eggnog/dbs \
--evalue 0.00001 \
--pident 35 \
--mp_start_method fork \
--itype proteins \
--tax_scope 33090 \
--target_orthologs all \
--go_evidence all \
--pfam_realign none \
--override \
-m diamond \
-o red5_all.fork 
EOF
sbatch eggnog.annotation.fork.sl


#These below blasts were done on my Mac as powerplant was too busy
#note added custom output fields so that we have the information we neeed later

blastp -query /Users/hrtjbs/Documents/v3.cat.clean.proteins.fasta \
-db ~/Documents/dbs/TAIR10_pep_20101214_updated \
-num_threads 10 \
-max_target_seqs 5 \
-outfmt "6 qseqid sseqid qlen slen stitle pident length sstart send qcovs evalue
 bitscore" \
-evalue 1e-10 \
-out red5.all.vs.tair.len.outfmt6

blastp -query /Users/hrtjbs/Documents/v3.cat.clean.proteins.fasta \
-db ~/Documents/dbs/uniprot_sprot.fasta \
-num_threads 10 \
-max_target_seqs 5 \
-outfmt "6 qseqid sseqid qlen slen stitle pident length sstart send qcovs evalue
 bitscore" \
-evalue 1e-10 \
-out red5.all.vs.uniprot.len.outfmt6
```

#### Parse annotation results and gffread output and populate scoring table

```{r}
library(tidyr)
#Read in the eggnog results (Annotations)
eggnog_ann = read.csv(file = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/eggnog_out.fork/red5_all.fork.emapper.annotations",
                      header = TRUE,
                      sep = "\t",
                      skip = 4)
#Read in the eggnog results (Diamond hits containing seed orthologues)
eggnog_seed = read.csv(file = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/eggnog_out.fork/red5_all.fork.emapper.seed_orthologs",
                        header = TRUE,
                        skip = 5,
                        sep = "\t")


#Read in tair and swissp  blast results
tair_raw = read.csv("/workspace/hrtjbs/pangene_2024/pangene/prototyping/blast/red5.all.vs.tair.len.outfmt6",sep = "\t",header = FALSE)
swissp_raw = read.csv("/workspace/hrtjbs/pangene_2024/pangene/prototyping/blast/red5.all.vs.uniprot.len.outfmt6",sep = "\t",header = FALSE)

#add headers
blast_col = c("qseqid", "sseqid", "qlen", "slen", "stitle", "pident", "length","sstart", "send", "qcovs", "evalue", "bitscore")
colnames(tair_raw) = blast_col
colnames(swissp_raw) = blast_col

#Get the best hit for each query and add prelim filter of 35 % idenity  and add scov (subject sequence coverage as a percentage)
#tair
tair_filt = tair_raw %>% 
  filter(pident > 35) %>% 
  group_by(qseqid) %>%
  slice_max(bitscore, n = 1,with_ties = FALSE) %>%
  ungroup()  %>% mutate("scov" =  (send - sstart) / slen * 100) %>%
  select(qseqid,qcovs,scov,pident) %>%
  dplyr::rename("tid"= qseqid,"tair_qcov" = qcovs,"tair_scov" = scov,"tair_pident" = pident)

#swissprot
swiss_filt = swissp_raw %>% 
  filter(pident > 35) %>% 
  group_by(qseqid) %>%
  slice_max(bitscore, n = 1,with_ties = FALSE) %>%
  ungroup()  %>% mutate("scov" =  (send - sstart) / slen * 100) %>%
  select(qseqid,qcovs,scov,pident) %>%
  dplyr::rename("tid"= qseqid,"swiss_qcov" = qcovs,"swiss_scov" = scov,"swiss_pident" = pident)


#eggnog
egg_filt = eggnog_seed %>%
  select(X.qseqid,qcov,scov,pident) %>%
  dplyr::rename("tid" = X.qseqid,"egg_qcov" = qcov,"egg_scov" = scov, "egg_pident" = pident)


#read in gffread results stringtie transcripts vs gene models
string_results_all = read.csv(file = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/gffcompare/v3.cat.clean.vs.transcripts.tracking",
                              sep = "\t",
                              header = FALSE)


string_results_all = string_results_all %>%
  filter(V4 == "=") %>%
  select(V5) %>%
  mutate(tid = sapply(strsplit(as.character(V5), split = "\\|"), function(x)  x[2] )) %>% 
  mutate(V5 = 1) %>% dplyr::rename("stringtie" = V5)


scoring_df = left_join(x = scoring_df,y = egg_filt,"tid")
scoring_df = left_join(x = scoring_df,y = tair_filt,"tid")
scoring_df = left_join(x = scoring_df,y = swiss_filt,"tid")
scoring_df = left_join(x = scoring_df,y = string.results.all,"tid") %>% 
dplyr::mutate(stringtie = tidyr::replace_na(stringtie, 0))

```

#### Plots: looking at different thresholds of scov 

```{r}
library(dplyr)
library(ggplot2)


#Create a dataframe with th enumber of proteins with hits above a set of scoverage thresholds so 
# I can plot the difference between liftoff genes and braker genes

thresholds = c(0,10, 20, 30, 40, 50, 60, 70, 80, 90)
threshold.results = data.frame()
for (threshold in thresholds) {
  for (coverage in c('egg_scov', 'tair_scov', 'swiss_scov')) {
    temp = scoring_df %>%
      filter(!!as.name(coverage) >= threshold) %>%
      group_by(Method) %>%
      summarise(Count = n()) %>%
      mutate(Coverage = coverage, Threshold = threshold)
    threshold.results = rbind(threshold.results,temp)
  }
}



#get the total number of genes in each method so we can express numbers as % of total
liftoff.genes = scoring_df %>% filter(Method == "Liftoff") %>% nrow()
braker.genes = scoring_df %>% filter(Method == "Braker3") %>% nrow()



#Get numbers passing threshold as percentage of total proteins in each method cat
threshold.results.pc = threshold.results %>%
  mutate(perc_total = case_when(
    Method == "Liftoff" ~ round((Count / liftoff.genes) * 100,digits = 2),
    Method == "Braker3" ~ round((Count / braker.genes) * 100,digits = 2)
  ))



# Enhanced ggplot
sscov.thresh.plot = ggplot(threshold.results.pc, aes(x = Threshold, y = perc_total, color = Coverage, group = interaction(Coverage, Method))) +
  geom_line( size = 0.25, position = position_dodge(0.2)) +  # Adjusted line aesthetics
  geom_point() +  # Adjusted point aesthetics
  facet_wrap(~Method) +
    scale_color_viridis_d(option = "D") +
  theme_minimal(base_size = 10) +  # Using a minimal theme for a cleaner look
  theme(legend.position = "bottom") +  # Moving legend to the bottom
  labs(
    title = "Proteins (%) passing threshold filters vs eggnog,swissprot,tair",  # Add a title
    x = "Threshold (percentage subject coverage)",  # Customizing x-axis label
    y = "Percentage of total proteins remaining",  # Customizing y-axis label
    fill = "Database",  # Customizing legend title for fill
    color = "Database"  # Customizing legend title for color
  )

ggsave(plot = sscov.thresh.plot,
       filename = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/sscov.thresh.plot.png",
       device = "png",
       units = "cm",
       width = 15,
       height = 21,
       dpi = 300,
       bg = "white")
```

```         
```

#### **Identity vs coverage plots**

```{r}

idcov.tair = ggplot(scoring_df, aes(x = tair_scov, y = tair_pident, color = Method)) +
  geom_point(stat = 'identity', size = 0.5,alpha = 0.4) +  
  theme_minimal(base_size = 10) +  
  scale_color_viridis_d(option = "D", begin = 0.2, end = 0.8, direction = 1, name = "Method") +
  labs(title = "Hits against tair protein db",
       x = "Coverage(Subject)",
       y = "Percentage identity")


idcov.egg = ggplot(scoring_df, aes(x = egg_scov, y = egg_pident, color = Method)) +
   geom_point(stat = 'identity', size = 0.5,alpha = 0.4) +   
  theme_minimal(base_size = 10) +  
  scale_color_viridis_d(option = "D", begin = 0.2, end = 0.8, direction = 1, name = "Method") +
  labs(title = "Hits against eggnog protein db",
       x = "Coverage(Subject)",
       y = "Percentage identity")


idcov.swiss = ggplot(scoring_df, aes(x = swiss_scov, y = swiss_pident, color = Method)) +
  geom_point(stat = 'identity', size = 0.5,alpha = 0.4) + 
  theme_minimal(base_size = 10) + 
  scale_color_viridis_d(option = 'D', begin = 0.2, end = 0.8, direction = 1, name = "Method") +
  labs(title = "Hits against swissprot protein db",
       x = "Coverage(Subject)",
       y = "Percentage identity")


ggsave(plot = idcov.egg,
       filename = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/idcov.egg.png",
       device = "png",
       units = "cm",
       width = 15,
       height = 15,
       dpi = 300,
       bg = "white")

ggsave(plot = idcov.tair,
       filename = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/idcov.tair.png",
       device = "png",
       units = "cm",
       width = 15,
       height = 15,
       dpi = 300,
       bg = "white")

ggsave(plot = idcov.swiss,
       filename = "/workspace/hrtjbs/pangene_2024/pangene/prototyping/idcov.swiss.png",
       device = "png",
       units = "cm",
       width = 15,
       height = 15,
       dpi = 300,
       bg = "white")
```

Select the best transcripts and gene models to be selected by pangene

```{r}
 tsdf = scoring_df
 
## We aren't going to support isoforms in this release so first step is start removing those isoforms we are confident are 
## wrong given our evidence
###  Remove isoforms that aren't supported by stringtie evidence (when at least another isoform at that locus has evidence)

 transcript_filter <- function(df, group_id) {
  group_col <- sym(group_id)
  df <- df %>%
    group_by(.data[[group_col]]) %>%
    mutate(has_stringtie_1 = any(stringtie == 1)) %>%
    ungroup()
  filtered_df <- df %>%
    filter(!(stringtie == 0 & has_stringtie_1)) %>%
    select(-has_stringtie_1)  # Remove the helper column
   return(filtered_df)
}


 #label the transcripts as gold / grey
transcript_labeler <- function(df, group_id, scov) {
 df <- df %>%
    group_by(!!sym(group_id)) %>%
    mutate(has_stringtie_1 = any(stringtie == 1),
           Tier = if_else(stringtie == 0 & has_stringtie_1 & Tier != "grey", "grey", Tier)) %>%
    ungroup() %>%
    select(-has_stringtie_1)

  golds <- df %>%
    filter(((egg_scov > scov & Method == "Braker3") | Method == "Liftoff") & Tier != "grey") %>%
    group_by(!!sym(group_id)) %>%
    arrange(desc(swiss_scov), desc(tair_scov), desc(egg_scov), .by_group = TRUE) %>%
    slice_head(n = 1) %>%
    ungroup() %>%
    mutate(Tier_Gold = "Gold") %>%
    select(tid, Tier_Gold)


  df <- left_join(df, golds, by = "tid")
  df <- df %>%
    mutate(Tier = ifelse(!is.na(Tier_Gold) & Tier != "grey", "Gold", Tier)) %>%
    select(-Tier_Gold) 

  return(df)
}

 
#testing the new func

tl.test = transcript_labeler(scoring_df,group_id = "ID",scov = 50) 

# transcript labeler function working but need to check further



#this function will filter by a certain scov value and then pick best transcript labelling gold
select_gold <- function(df, group_id, scov) {
  group_col = sym(group_id)
  gold.genes = df %>%
    filter((egg_scov > scov & Method == "Braker3") | Method == "Liftoff") %>%
    group_by(.data[[group_col]]) %>%
    arrange(desc(swiss_scov), desc(tair_scov), desc(egg_scov), .by_group = TRUE) %>%
    slice_head(n = 1) %>%
    mutate("Tier" = "Gold") %>%
    ungroup() %>%
    select(tid, Tier) %>%
   as.data.frame() 
   df <- df %>%
    left_join(gold.genes, by = "tid") %>%
    mutate(Tier = ifelse(is.na(Tier), "", Tier))  
   return(df)
}



df.gold = select_gold(df = sdf.sf,group_id = "ID",scov = 50)









```
